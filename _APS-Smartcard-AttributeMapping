#!/bin/bash
#
####################################################################################################
#
# The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
# MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
# THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
# OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
#
# IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
# OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
# MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
# AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
# STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
####################################################################################################
#
# ABOUT THIS PROGRAM
#
# NAME
#
# Smartcard-AttributeMapping.sh
#
# This process is intended to pair/map a smart card/PIV/CAC/Yubikey to a local user account using attribute mapping.
#
# The "Subject Alternative Name/NT Principal Name" from the card is mapped to "AltSecurityIdentities Kerberos" in
# the local directory services using dscl.
# UPN="Subject Alternative Name/NT Principal Name" from the card
# dscl . -create /Users/"$currentUser" AltSecurityIdentities Kerberos:"$UPN" (alternatively PlatformSSO )
#
# "/etc/SmartcardLogin.plist" must also be configured for offline smart card login via kerberos caching or PlatformSSO.
# "man SmartCardServices" for the offline smart card login via kerberos caching example.
#
# Mac systems do not have to be bound to AD to use attribute mapping. However, if a Mac system is bound to AD
# additional AD users will be able to log in (creating an AD mobile account) using smart cards and/or username and password.
# If the smart card does not include "Subject Alternative Name/NT Principal Name" this process will fail.
#
ScriptVersion="2024-09-12"
# v2023-10-13 -	Sonoma Support - Added testFVTokenSecret. Changed lock screen from "pmset displaysleepnow" to opening ScreenSaverEngine as current user.
# v2023-10-17 -	Sonoma Support - Added "defaults write /Library/Preferences/com.apple.loginwindow screenUnlockMode -int 0" to testFVTokenSecret_after_ScreenSaverEngine. 
# 				This sets the screenUnlockMode to behave like pre-Sonoma. This will bring back the login keychain password prompt. The screenUnlockMode key is reset/deleted after.
# v2023-10-18 -	Using "/bin/launchctl asuser "$currentUserUID" sudo -iu "$currentUser"" with sc_auth commands for Workspace ONE compatibility.
# v2023-10-24 -	Added logging to /private/var/log/Smartcard-AttributeMapping.log
# v2023-12-14 - Added a log out option. This is helpful when using a smart card profile with the "lock screen on smart card removal" option.
# 				Aligned version numbers with all the related smart card scripts
# v2024-02-05 -	Added support for com.smartcard.workflow.settings configuration profile settings
# 				Updated testFVTokenSecret - added "/usr/sbin/diskutil apfs updatePreboot /"
# v2024-03-14 - Aligned version numbers with all the related smart card scripts
# v2024-06-06 - Added sc_auth filevault to prompt for Keychain password and to setup FVTokenSecret
# v2024-07-11 - Updated Check_For_UsersToExclude to check the smartcardexclusion group for users to exclude
# v2024-09-12 - Added options for PlatformSSO - AttributeMapping_formatString
#				Updated createAltSecId to disable Power Nap. Power Nap can interfere with smart card readers waking from sleep.
#
####################################################################################################
#
# LOGGING AND LOG FILES
#
####################################################################################################
logFile="/private/var/log/smartcard-management.log"
/usr/bin/touch "$logFile"
# Purpose: Provides custom logging for the application
# Use: log "text to log"
# Dependencies: logFile variable needs to be defined

Shell_Script_Name="$(/usr/bin/basename "${0}")"
dateFormat=$(/bin/date "+%Y-%m-%d %H:%M:%S %Z:")
function log () {
	# Send the echo to stdout
	/bin/echo $1
	# Send the echo to the logFile
	/bin/echo ${dateFormat} ${Shell_Script_Name}: $1 >> "${logFile}"
}
#
####################################################################################################
#
# DEFINE VARIABLES & READ IN PARAMETERS
#
####################################################################################################

# HARDCODED VALUES ARE SET HERE
unset TRY_Check_for_PIV_Auth_Cert
unset TRY_verifypin
unset SmartCardPIN

# Custom Configuration Profile Domain
ConfigurationProfileDomain="com.smartcard.workflow.settings"

# macOS version
sw_vers_Full=$(/usr/bin/sw_vers -productVersion)
sw_vers_Full_Integer=$(/usr/bin/sw_vers -productVersion | /usr/bin/awk -F. '{for(i=1; i<=NF; i++) {printf("%02d",$i)}}')
sw_vers_Major=$(/usr/bin/sw_vers -productVersion | /usr/bin/cut -d. -f 1,2)
sw_vers_Major_Integer=$(/usr/bin/sw_vers -productVersion | /usr/bin/cut -d. -f 1,2 | /usr/bin/awk -F. '{for(i=1; i<=NF; i++) {printf("%02d",$i)}}')
sw_vers_MajorNumber=$(/usr/bin/sw_vers -productVersion | /usr/bin/cut -d. -f 2)

# Jamf Environmental Positional Variables.
# $1 Mount Point
# $2 Computer Name
# $3 Current User Name - This can only be used with policies triggered by login or logout.
# Declare the Environmental Positional Variables so the can be used in function calls.
mountPoint=$1
computerName=$2
username=$3
currentUser=$(/bin/echo 'show State:/Users/ConsoleUser' | /usr/sbin/scutil | /usr/bin/awk '/Name / { print $3 }')
currentUserUID=$(id -u "$currentUser")
computerName=$(/usr/sbin/scutil --get ComputerName)

log "Preparing to map smart card for $currentUser"
log "${computerName} is running macOS version ${sw_vers_Full}"

######
# Read /etc/SmartcardLogin.plist to get the formatString. Kerberos, PlatformSSO, etc...
if [ -e "/etc/SmartcardLogin.plist" ];then
	AttributeMapping_formatString=$(/usr/libexec/PlistBuddy -c "print :AttributeMapping:formatString" /etc/SmartcardLogin.plist 2> /dev/null | /usr/bin/awk -F ':' '{print $1}')
fi

if [ -z "$AttributeMapping_formatString" ];then
	# If there is no AttributeMapping_formatString defined default to Kerberos
	AttributeMapping_formatString="Kerberos"
fi
#
######

######
# HARDCODED VALUE FOR "ImageFilePath" IS SET HERE
# Jamf Parameter Value Label - Image file path or URL
# A Jamf self service icon can be pulled down right from the jamf server.
# Right click on a self service icon to get the url - https://your.jamf.server/icon?id=XX 
ImageFilePath="/System/Library/Frameworks/CryptoTokenKit.framework/ctkbind.app/Contents/Resources/AppIcon.icns"

# CHECK TO SEE IF A VALUE WAS SPECIFIED VIA CONFIGURLATION PROFILE IF SO, ASSIGN TO "ImageFilePath"
# If a value is specified via a configuration profile, it will override the hardcoded value in the script.
ImageFilePath_ConfigProfile=$(/usr/bin/defaults read /Library/Managed\ Preferences/${ConfigurationProfileDomain} ImageFilePath 2> /dev/null)
if [ "$ImageFilePath_ConfigProfile" != "" ];then
	log "ImageFilePath_ConfigProfile is $ImageFilePath_ConfigProfile"
	ImageFilePath="$ImageFilePath_ConfigProfile"
fi

# CHECK TO SEE IF A VALUE WAS PASSED IN PARAMETER 4 AND, IF SO, ASSIGN TO "ImageFilePath"
# If a value is specified via a Jamf policy, it will override the hardcoded value in the script.
if [ "$4" != "" ];then
	ImageFilePath="$4"
fi

# If an http(s) url is specified, get the icon from the url
if [[ "$ImageFilePath" = "http"* ]] ; then
	/usr/bin/curl --output "/tmp/ImageFile" "$ImageFilePath"
	ImageFilePath="/tmp/ImageFile"
	/bin/echo "$ImageFilePath"
# If the path ends with *.app use the app icon
elif [[ "$ImageFilePath" = *".app" ]] || [[ "$ImageFilePath" = *".prefPane" ]] ; then
	CFBundleIconFile=$(/usr/bin/defaults read "$ImageFilePath"/Contents/Info.plist CFBundleIconFile 2> /dev/null)
	CFBundleIconName=$(/usr/bin/defaults read "$ImageFilePath"/Contents/Info.plist CFBundleIconName 2> /dev/null)
	if [[ "${CFBundleIconFile}" ]] ; then
	# If the app icon is in Contents/Resources copy it to /tmp/ImageFile.icns
		IconFileFullPath="$ImageFilePath"/Contents/Resources/"$CFBundleIconFile"
		/bin/cp "$IconFileFullPath"* "/tmp/IconFile"
		ImageFilePath="/tmp/ImageFile"
		/bin/echo "$ImageFilePath"
	elif [[ "$CFBundleIconName" ]] ; then
	# If the app icon in embedded within the Assets.car
		/usr/bin/iconutil -c icns "$ImageFilePath"/Contents/Resources/Assets.car "$CFBundleIconName" -o /tmp/ImageFile.icns
		/bin/mv "/tmp/ImageFile.icns" "/tmp/ImageFile" #remove icns from the file name
		ImageFilePath="/tmp/ImageFile"
		/bin/echo "$ImageFilePath"
	else
	ImageFilePath=""
	fi
fi
log "ImageFilePath is $ImageFilePath"
######

######
# HARDCODED VALUE FOR "MarkPIVMandatory" IS SET HERE
# Upon successful smart card mapping mark PIV Mandatory.
# Jamf Parameter Value Label - Mark as PIV Mandatory (yes|no)
MarkPIVMandatory="no"
# CHECK TO SEE IF A VALUE WAS SPECIFIED VIA CONFIGURLATION PROFILE IF SO, ASSIGN TO "MarkPIVMandatory"
# If a value is specified via a configuration profile, it will override the hardcoded value in the script.
MarkPIVMandatory_ConfigProfile=$(/usr/bin/defaults read /Library/Managed\ Preferences/${ConfigurationProfileDomain} MarkPIVMandatory 2> /dev/null)
if [ "$MarkPIVMandatory_ConfigProfile" != "" ];then
	log "MarkPIVMandatory_ConfigProfile: $MarkPIVMandatory_ConfigProfile"
	MarkPIVMandatory="$MarkPIVMandatory_ConfigProfile"
fi

# CHECK TO SEE IF A VALUE WAS PASSED IN PARAMETER 5 AND, IF SO, ASSIGN TO "MarkPIVMandatory"
# If a value is specified via a Jamf policy, it will override the hardcoded value in the script.
if [ "$5" != "" ];then
	MarkPIVMandatory="$5"
fi
log "MarkPIVMandatory: $MarkPIVMandatory"
######

######
# HARDCODED VALUE FOR "UsersToExclude" IS SET HERE
# List of local users that should not be prompted to map a smart card
# Jamf Parameter Value Label - Users to exclude (separated by spaces)
UsersToExclude=""
# CHECK TO SEE IF A VALUE WAS SPECIFIED VIA CONFIGURLATION PROFILE IF SO, ASSIGN TO "UsersToExclude"
# If a value is specified via a configuration profile, it will override the hardcoded value in the script.
UsersToExclude_ConfigProfile=$(/usr/bin/defaults read /Library/Managed\ Preferences/${ConfigurationProfileDomain} UsersToExclude 2> /dev/null)
if [ "$UsersToExclude_ConfigProfile" != "" ];then
	log "UsersToExclude_ConfigProfile: $UsersToExclude_ConfigProfile"
	UsersToExclude="$UsersToExclude_ConfigProfile"
fi

# CHECK TO SEE IF A VALUE WAS PASSED IN PARAMETER 6 AND, IF SO, ASSIGN TO "UsersToExclude"
# If a value is specified via a Jamf policy, it will override the hardcoded value in the script.
if [ "$6" != "" ];then
	UsersToExclude="$6"
fi
log "UsersToExclude: $UsersToExclude"
######

######
# HARDCODED VALUE FOR "LogOutWhenComplete" IS SET HERE
# Upon successful smart card mapping log out.
# Jamf Parameter Value Label - Log out when complete (yes|no)
LogOutWhenComplete="no"
# CHECK TO SEE IF A VALUE WAS SPECIFIED VIA CONFIGURLATION PROFILE IF SO, ASSIGN TO "LogOutWhenComplete"
# If a value is specified via a configuration profile, it will override the hardcoded value in the script.
LogOutWhenComplete_ConfigProfile=$(/usr/bin/defaults read /Library/Managed\ Preferences/${ConfigurationProfileDomain} LogOutWhenComplete 2> /dev/null)
if [ "$LogOutWhenComplete_ConfigProfile" != "" ];then
	log "LogOutWhenComplete_ConfigProfile: $LogOutWhenComplete_ConfigProfile"
	LogOutWhenComplete="$LogOutWhenComplete_ConfigProfile"
fi

# CHECK TO SEE IF A VALUE WAS PASSED IN PARAMETER 7 AND, IF SO, ASSIGN TO "LogOutWhenComplete"
# If a value is specified via a Jamf policy, it will override the hardcoded value in the script.
if [ "$7" != "" ];then
	LogOutWhenComplete="$7"
fi
log "LogOutWhenComplete: $LogOutWhenComplete"
######

####################################################################################################
#
# Functions to call on
#
####################################################################################################

#
### Ensure we are running this script as root ###
function rootcheck () {
# log "Begin ${FUNCNAME[0]}"
if [ "$(/usr/bin/whoami)" != "root" ]; then
	log "This script must be run as root or sudo."
	exit 1
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Wait for the Dock.
function Wait_For_Dock () {
# log "Begin ${FUNCNAME[0]}"
dockStatus=$(/usr/bin/pgrep -x Dock)
while [ "$dockStatus" == "" ]; do
	/bin/sleep 2
	dockStatus=$(/usr/bin/pgrep -x Dock)
done
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Check for Users to Exclude.
function Check_For_UsersToExclude () {
# log "Begin ${FUNCNAME[0]}"
NotEnforcedGroup=$(/usr/bin/defaults read /etc/SmartcardLogin.plist NotEnforcedGroup 2> /dev/null)
NotEnforcedGroupMembers=$(/usr/bin/dscacheutil -q group -a name ${NotEnforcedGroup} 2> /dev/null | /usr/bin/awk '/users:/ { $1=""; print $0 }')
for Each_NotEnforcedGroupMembers in $NotEnforcedGroupMembers ; do
	if [[ "${currentUser}" == "$NotEnforcedGroupMembers" ]]; then
		Message="Current user ${currentUser} is not intended to use a smart card."
		log "${Message} NotEnforcedGroup"
		/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Ok\"} default button 1"
		exit 0
	fi
done

for Each_UsersToExclude in $UsersToExclude ; do
	if [[ "${currentUser}" == "$Each_UsersToExclude" ]]; then
		Message="Current user ${currentUser} is not intended to use a smart card."
		log "${Message} UsersToExclude list"
		/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Ok\"} default button 1"
		exit 0
	fi
done

IsHidden=$(/usr/bin/dscl . -read /Users/"$currentUser" 2> /dev/null | /usr/bin/grep -c "dsAttrTypeNative:IsHidden: 1")
if [[ "${currentUserUID}" -lt 501 ]] || [[ "$IsHidden" > 0 ]]; then
		Message="Current user ${currentUser} is not intended to use a smart card."
		log "${Message} Hidden User"
		/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Ok\"} default button 1"
		exit 0
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Check current user for mapped smart card
function Check_current_user_for_mapped_smart_card (){
# log "Begin ${FUNCNAME[0]}"
altSecCheckCount=$(/usr/bin/dscl . -read /Users/"$currentUser" AltSecurityIdentities 2> /dev/null | /usr/bin/grep -c ${AttributeMapping_formatString})
amidentityCheck=$(/usr/bin/dscl . -read /Users/"$currentUser" AuthenticationAuthority 2> /dev/null | /usr/bin/grep -c amidentity)
FVTokenSecret=$(/usr/bin/dscl . -read /Users/"$currentUser" dsAttrTypeNative:FVTokenSecret 2> /dev/null)
if [[ "$altSecCheckCount" != 0 ]] && [[ "$amidentityCheck" != 0 ]] && [[ "${FVTokenSecret}" ]]; then
	# Begin dialog box message
	altSecCheck=$(/usr/bin/dscl . -read /Users/"$currentUser" AltSecurityIdentities 2> /dev/null | /usr/bin/sed -n 's/.*${AttributeMapping_formatString}:\([^ ]*\).*/\1/p')
	Message="Current user ${currentUser} already has a smart card. \nTo proceed un-map or re-map the smart card for ${altSecCheck}."
	log "${Message}"
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Ok\"} default button 1"
	exit 0
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Mark system as PIV Mandatory ###
function MarkPIVMandatory_Yes_or_No () {
# log "Begin ${FUNCNAME[0]}"
if [ "$MarkPIVMandatory" = "yes" ]; then
	/bin/mkdir -p /private/var/EnterpriseManagement/
	/usr/bin/defaults write "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory -bool true 2> /dev/null
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatoryUndoDate 2> /dev/null
	/usr/bin/plutil -convert xml1 "/private/var/EnterpriseManagement/com.apple.enterprisedeployment.plist"
else
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory 2> /dev/null
	/usr/bin/plutil -convert xml1 "/private/var/EnterpriseManagement/com.apple.enterprisedeployment.plist"
fi

PIVMandatorySetting=$(/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" "PIVMandatory" 2> /dev/null)
if [ "$PIVMandatorySetting" = "1" ]; then
	PIVMandatorySetting="1"
else
	PIVMandatorySetting="0"
fi
PIVMandatory=$PIVMandatorySetting
log "PIVMandatory = ${PIVMandatorySetting}"
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Verify that CryptoTokenKit is enabled and functioning ###
function EnableCTK () {
# log "Begin ${FUNCNAME[0]}"
/usr/bin/defaults write /Library/Preferences/com.apple.security.smartcard allowUnmappedUsers -int 1
/usr/bin/security smartcards token -e com.apple.CryptoTokenKit.pivtoken > /dev/null
/usr/bin/defaults delete /Library/Preferences/com.apple.security.smartcard DisabledTokens 2> /dev/null
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Intro Message.
function IntroMessage (){
# log "Begin ${FUNCNAME[0]}"
Message="This will enable smart card login for the user $currentUser. \nDo NOT continue unless you know your PIN. \n\nPlease insert your smart card to begin. \nv${ScriptVersion}"
#
/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\" , \"Cancel\"} default button 1"
# Stop everything if the cancel button is pressed.
if [ $? -eq 1 ]; then
	log "${currentUser} canceled smart card mapping process."
	exit 0
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Prompt the user to insert card.
function Check_for_PIV_Auth_Cert (){
# log "Begin ${FUNCNAME[0]}"
# Command to force a restart of USB services for some smart card readers
/usr/bin/killall - STOP usbd
# Check for a smart card with a PIV Authentication certificate
PIV_Auth_Cert_Count=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth identities | /usr/bin/grep -c "PIV Authentication")
#
TRY_Check_for_PIV_Auth_Cert=1
while [[ ${PIV_Auth_Cert_Count} -ne 1 ]]; do
	if [ "$TRY_Check_for_PIV_Auth_Cert" -eq 5 ]; then
		Message="This smart card is not recognized. \nPlease contact you system administrator."
		button1="Cancel"
		log "${Message}"
		log "${currentUser} canceled smart card mapping process."
		/usr/bin/osascript -e "display dialog \"${Message}\" with title \"${title}\" with icon POSIX file \"${ImageFilePath}\" buttons {\"${button1}\"} default button 1 giving up after 30" > /dev/null &
		unset TRY_Check_for_PIV_Auth_Cert
		exit 0
	else
		(( TRY_Check_for_PIV_Auth_Cert++ ))
		if [[ ${PIV_Auth_Cert_Count} -lt 1 ]]; then
			Message="Smart card not detected. \nPlease re-insert your smart card to begin."	
		elif [[ ${PIV_Auth_Cert_Count} -gt 1 ]]; then
			Message="Multiple smart cards detected. \nPlease insert only one smart card."
		fi
		/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\" , \"Cancel\"} default button 1"
		# Stop everything if the cancel button is pressed.
		if [ $? -eq 1 ]; then
			log "${currentUser} canceled smart card mapping process."
			exit 0
		fi
		/bin/sleep 1
		PIV_Auth_Cert_Count=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth identities | /usr/bin/grep -c "PIV Authentication")
	fi
done
log "Smart card detected"
# log "End ${FUNCNAME[0]}"
}
###
#

#
### verify Smart Card PIN ###
function verifySmartCardPIN () {
# log "Begin ${FUNCNAME[0]}"
smartCardVerification=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth verifypin -p "${SmartCardPIN}" 2>/dev/null)
# Checking for "PIN verified" or "PIN verifyied" due to spelling error in macOS Catalina sc_auth verifypin command
# Big Sur returns "PIN verifyied" Note the extra "y"
# "$smartCardVerification" == "" is there if using - Two Canoes Remote Access - https://twocanoes.com/solutions/remote-access/
if [[ "$smartCardVerification" =~ "PIN verified" ]] || [[ "$smartCardVerification" =~ "PIN verifyied" ]] || [[ "$smartCardVerification" == "" ]] ; then
	log "${currentUser} smart card PIN verified."
	return 0
else
	return 1
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Test Smart Card PIN ###
function Test_Smart_Card_PIN () {
# log "Begin ${FUNCNAME[0]}"
Message="Please verify your Smart Card PIN."
title="Smart Card PIN"
SmartCardPIN=$(/usr/bin/osascript -e "display dialog \"${Message}\" default answer \"\" with hidden answer with title \"${title}\" with icon POSIX file \"${ImageFilePath}\" giving up after 86400" -e "return text returned of result")

if [ $? -eq 1 ]; then
	log "${currentUser} canceled smart card mapping process."
	unset SmartCardPIN
	exit 0
fi

if [[ -z "${SmartCardPIN}" ]]; then
	SmartCardPIN="emptyPIN"
fi

TRY_verifypin=1

until verifySmartCardPIN; do
	# log "This is TRY_verifypin number $TRY_verifypin at the start of the Unitl loop"
	if [ "$TRY_verifypin" -eq 2 ]; then
		Message="You've made two incorrect PIN attempts. Exiting now."
		button1="Cancel"
		log "${Message}"
		log "${currentUser} canceled smart card mapping process."
		/usr/bin/osascript -e "display dialog \"${Message}\" with title \"${title}\" with icon POSIX file \"${ImageFilePath}\" buttons {\"${button1}\"} default button 1 giving up after 30" > /dev/null &
		unset SmartCardPIN
		exit 0
	else
		# Checking for "PIN verified" or "PIN verifyied" due to spelling error in macOS Catalina sc_auth verifypin command
		# Catalina returns "PIN verifyied" Note the extra y
		(( TRY_verifypin++ ))

		Message="That PIN was incorrect. Please try again:"
		unset SmartCardPIN
		SmartCardPIN=$(/usr/bin/osascript -e "display dialog \"${Message}\" default answer \"\" with hidden answer with title \"${title}\" with icon POSIX file \"${ImageFilePath}\" giving up after 86400" -e "return text returned of result")
		if [ $? -eq 1 ]; then
			log "${currentUser} canceled smart card mapping process."
			unset SmartCardPIN
			exit 0
		fi

		if [[ -z "${SmartCardPIN}" ]]; then
			SmartCardPIN="emptyPIN"
		fi
	fi
done

unset SmartCardPIN
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Check for an already paired smart card ##
function checkForPaired (){
# log "Begin ${FUNCNAME[0]}"
tokenCheck=$(/usr/bin/dscl . -read /Users/"$currentUser" AuthenticationAuthority | /usr/bin/grep -c tokenidentity)
if [[ "$tokenCheck" > 0 ]]; then
	# Delete any existing paired smart cards
	log "Unpairing ${currentUser} smart card"
	/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth unpair -u "$currentUser"
	log "Removing ${currentUser} FVTokenSecret"
	/bin/launchctl asuser "0" /usr/bin/sudo -iu "root" /usr/sbin/sc_auth filevault -o disable -u "$currentUser"
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Get the PIV Identity Hash for UPN ###
function getUPN(){
# log "Begin ${FUNCNAME[0]}"
# Create temp dir to export certs
# tmpdir=$(/usr/bin/mktemp -d)
tmpdir=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/bin/mktemp -d)

# Dump card's certs
# /usr/bin/security export-smartcard -e "$tmpdir"
/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/bin/security export-smartcard -e "${tmpdir}"

# Get PIV cert
piv_path=$(/bin/ls "$tmpdir" | /usr/bin/grep '^Certificate For PIV')

# Get UPN
UPN=$(/usr/bin/openssl asn1parse -i -dump -in "$tmpdir/$piv_path" -strparse $(/usr/bin/openssl asn1parse -i -dump -in "$tmpdir/$piv_path" | /usr/bin/awk -F ':' '/X509v3 Subject Alternative Name/ {getline; print $1}') | /usr/bin/awk -F ':' '/UTF8STRING/{print $4}')
log "UPN: $UPN"

checkPIVAuthCertExpiration

# clean up
/bin/rm -rf $tmpdir
# log "End ${FUNCNAME[0]}"
}
###
#

#
### check the PIV Authentication Certificate Expiration ###
function checkPIVAuthCertExpiration(){
# log "Begin ${FUNCNAME[0]}"
CertExpiration_date=$(/usr/bin/openssl x509 -enddate -noout -in "$tmpdir/$piv_path" | /usr/bin/awk -F '=' '{print $NF}' | /usr/bin/awk '{print $1,$2,$4}')
CertExpiration_0_Days=$(/usr/bin/openssl x509 -checkend 0 -in "$tmpdir/$piv_path") #
CertExpiration_4_Weeks=$(/usr/bin/openssl x509 -checkend 2419200 -in "$tmpdir/$piv_path") # 4 weeks = 2419200 seconds
CertExpiration_26_Weeks=$(/usr/bin/openssl x509 -checkend 15724800 -in "$tmpdir/$piv_path") # 26 weeks = 15724800
if [[ "$CertExpiration_0_Days" == "Certificate will expire" ]]; then
	# PIV Authentication Certificate has expired
	title="Certificate Expired"
	Message="The PIV Authentication certificate on this smart card expired ${CertExpiration_date}. \n\nYou must renew this smart card before you can use it."
	log "${Message}"
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"${title}\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Cancel\"} default button 1 giving up after 30" > /dev/null &
	log "Setting PIVMandatory to false"
	/bin/mkdir -p /private/var/EnterpriseManagement/
	/usr/bin/defaults write "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory -bool false 2> /dev/null 
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatoryUndoDate 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVMandatory"
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" NTPrincipalName 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "NTPrincipalName"
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVAuthCert_Expiration 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVAuthCert_Expiration"
    /usr/bin/dscl . -delete /Users/"$currentUser" SmartCardEnforcement
	exit 0
elif [[ "$CertExpiration_4_Weeks" == "Certificate will expire" ]]; then
	# PIV Authentication Certificate will expire within 4 weeks
	title="Certificate Expiring"
	Message="The PIV Authentication certificate on this smart card will expire ${CertExpiration_date}. \n\nPlease renew this smart card as soon as possible. \nUsing this smart card prior to renewing is not recommended."
	log "${Message}"
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Cancel\" , \"Continue\"} default button 1 giving up after 30"
	# Stop everything if the cancel button is pressed.
	if [ $? -eq 1 ]; then
		log "${currentUser} canceled smart card mapping process."
		log "Setting PIVMandatory to false"
		/bin/mkdir -p /private/var/EnterpriseManagement/
		/usr/bin/defaults write "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory -bool false 2> /dev/null 
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatoryUndoDate 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVMandatory"
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" NTPrincipalName 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "NTPrincipalName"
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVAuthCert_Expiration 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVAuthCert_Expiration"
		/usr/bin/dscl . -delete /Users/"$currentUser" SmartCardEnforcement
		exit 0
	fi
elif [[ "$CertExpiration_26_Weeks" == "Certificate will expire" ]]; then
	# PIV Authentication Certificate will expire within 6 months
	title="Certificate Expiring"
	Message="The PIV Authentication certificate on this smart card will expire ${CertExpiration_date}. \n\nPlease renew this smart card as soon as possible."
	log "${Message}"
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\" , \"Cancel\"} default button 1"
	# Stop everything if the cancel button is pressed.
	if [ $? -eq 1 ]; then
		log "${currentUser} canceled smart card mapping process."
		log "Setting PIVMandatory to false"
		/bin/mkdir -p /private/var/EnterpriseManagement/
		/usr/bin/defaults write "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory -bool false 2> /dev/null 
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatoryUndoDate 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVMandatory"
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" NTPrincipalName 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "NTPrincipalName"
		/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVAuthCert_Expiration 2> /dev/null 
		/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVAuthCert_Expiration"
		/usr/bin/dscl . -delete /Users/"$currentUser" SmartCardEnforcement
		exit 0
	fi
else
	log "PIV Authentication Certificate is not expired and is not expiring soon"
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Create AltSecurityIdentities for current user
function createAltSecId (){
# log "Begin ${FUNCNAME[0]}"
if [ -z "$UPN" ]; then
# The smart card does not have a properly configured PIV Authentication cert with a Subject Alternative Name and NT Principal Name.
# Begin dialog box message
	Message="Smart card mapping was unsuccessful. NT Principal Name is not properly configured for this card. \n\nPlease contact your administrator for assistance."
# End dialog box message
	log "${Message}"
	rv=$(/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\"} default button 1")
	log "Setting PIVMandatory to false"
	/bin/mkdir -p /private/var/EnterpriseManagement/
	/usr/bin/defaults write "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatory -bool false 2> /dev/null 
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVMandatoryUndoDate 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVMandatory"
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" NTPrincipalName 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "NTPrincipalName"
	/usr/bin/defaults delete "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" PIVAuthCert_Expiration 2> /dev/null 
	/usr/bin/defaults read "/private/var/EnterpriseManagement/com.apple.enterprisedeployment" 2> /dev/null | /usr/bin/grep "PIVAuthCert_Expiration"
    /usr/bin/dscl . -delete /Users/"$currentUser" SmartCardEnforcement
	exit 0
else
	# The smart card is properly configured and will be mapped to this user.
	# Begin dialog box message
	Message1="Successfully added $UPN to $currentUser.  \n\n!!!YOUR ACTION REQUIRED!!! \n\nPlease remove and re-insert your smart card."
	Message2="!!!YOUR ACTION REQUIRED!!! \n\nClick Continue to lock the screen. \n\nWait 10 seconds, then use your PIN to unlock the screen. \n\nYou may be prompted once for your keychain password after unlocking the screen."

	# Delete any axisting AltSecurityIdentities
	/usr/bin/dscl . -delete /Users/"$currentUser" AltSecurityIdentities
	# Create new AltSecurityIdentities
	/usr/bin/dscl . -create /Users/"$currentUser" AltSecurityIdentities ${AttributeMapping_formatString}:"$UPN"
	# Command to force a restart of USB services for some smart card readers
	/usr/bin/killall - STOP usbd
	# Add amidentity from PIV
	PIV_Auth_Cert_hash=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth identities | awk '/PIV Authentication/ {print $1}')
	/usr/bin/dscl . -append /Users/"$currentUser" AuthenticationAuthority ";amidentity;$PIV_Auth_Cert_hash"
	# Prompt user for login keychain password
	/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth filevault -o enable -u "$currentUser" -h $PIV_Auth_Cert_hash
	log "${Message1}"
	rv=$(/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message1}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\"} default button 1")
	rv=$(/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message2}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\"} default button 1")
	MarkPIVMandatory_Yes_or_No
	/usr/bin/dscl . -delete /Users/"$currentUser" SmartCardEnforcement
	log "Disabling Power Nap"
	/usr/bin/pmset -a powernap 0
	testFVTokenSecret_after_ScreenSaverEngine
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Disable Power Nap
function disable_Power_Nap () {
# log "Begin ${FUNCNAME[0]}"
log "Disabling Power Nap"
/usr/bin/pmset -a powernap 0
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Wait for ScreenSaverEngine to to stop then testFVTokenSecret
function testFVTokenSecret_after_ScreenSaverEngine () {
# log "Begin ${FUNCNAME[0]}"
# Set screenUnlockMode to behave like pre-Sonoma. This will allow the login keychain password prompt to appear after PIN unlock.
/usr/bin/defaults write /Library/Preferences/com.apple.loginwindow screenUnlockMode -int 0
# Use screen saver to lock the screen. THis will force the user to unlock using their smart card and PIN.
/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/bin/open /System/Library/CoreServices/ScreenSaverEngine.app

log "Waiting for ScreenSaverEngine to end"
/bin/sleep 5
ScreenSaverEngineStatus=$(/usr/bin/pgrep -x ScreenSaverEngine 2> /dev/null)
while [ "$ScreenSaverEngineStatus" ]; do
	/bin/sleep 5
	ScreenSaverEngineStatus=$(/usr/bin/pgrep -x ScreenSaverEngine 2> /dev/null)
done

# Undo screenUnlockMode
/usr/bin/defaults delete /Library/Preferences/com.apple.loginwindow screenUnlockMode

testFVTokenSecret
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Test to see if the smart card KMK was used to create a FVTokenSecret and encrypt the login.keychain
function testFVTokenSecret(){
# log "Begin ${FUNCNAME[0]}"
FVTokenSecret=$(/usr/bin/dscl . -read /Users/"$currentUser" dsAttrTypeNative:FVTokenSecret 2> /dev/null)
if [[ ! "${FVTokenSecret}" ]]; then
	log "Prompting ${currentUser} for login keychain".
	PIV_Auth_Cert_hash=$(/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth identities | awk '/PIV Authentication/ {print $1}')
	/bin/launchctl asuser "$currentUserUID" /usr/bin/sudo -iu "$currentUser" /usr/sbin/sc_auth filevault -o enable -u "$currentUser" -h $PIV_Auth_Cert_hash
fi

FVTokenSecret=$(/usr/bin/dscl . -read /Users/"$currentUser" dsAttrTypeNative:FVTokenSecret 2> /dev/null)
amidentityCheck=$(/usr/bin/dscl . -read /Users/"$currentUser" AuthenticationAuthority 2> /dev/null | /usr/bin/grep -c amidentity)
if [[ ! "${FVTokenSecret}" ]] || [[ "$amidentityCheck" == 0 ]] ; then
	log "FVTokenSecret is NOT properly configured for ${currentUser}".
	log "Prompting ${currentUser} to logout to complete smart card mapping."
	Message="!!!LOG OUT REQUIRED!!! \n\nYou must log out now to enable smart card authentication. \n\nSave all files and close all apps before proceeding.  \nYou will automatically be logged out after clicking the Log Out button. \n\nOnce logged out please log back in. \n\nYou may be prompted once for your keychain password when logging back in."
	#
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Log Out\"} default button 1"
	# Create script and LaunchAgent to Log out current user
	Create_LogOut_Script
	Create_LogOut_LaunchAgent
elif [[ "$LogOutWhenComplete" = "yes" ]]; then
	/usr/sbin/diskutil apfs updatePreboot /
	log "FVTokenSecret is configured for ${currentUser}".
	log "Smart card mapping complete. Prompting ${currentUser} to logout."
	Message="!!!LOG OUT REQUIRED!!! \n\nYou must log out now to enable smart card authentication. \n\nSave all files and close all apps before proceeding.  \nYou will automatically be logged out after clicking the Log Out button."
	#
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Log Out\"} default button 1"
	# Create script and LaunchAgent to Log out current user
	Create_LogOut_Script
	Create_LogOut_LaunchAgent
	log "Smart card mapping complete. Logout not required."
else
	/usr/sbin/diskutil apfs updatePreboot /
	Message="Smart card mapping complete."
	log "FVTokenSecret is configured for ${currentUser}".
	log "Smart card mapping complete."
	/usr/bin/sudo -u "$currentUser" /usr/bin/osascript -e "display dialog \"${Message}\" with title \"Smart Card Mapping\" with icon POSIX file \"${ImageFilePath}\" buttons {\"Continue\"} default button 1" &
fi
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Create script LogOutUser.sh ###
function Create_LogOut_Script () {
log "Begin ${FUNCNAME[0]}"
/bin/cat > "/private/tmp/LogOutUser.sh" << 'SCRIPT'
#!/bin/sh
#
currentUser=$(/bin/echo 'show State:/Users/ConsoleUser' | /usr/sbin/scutil | /usr/bin/awk '/Name / { print $3 }')
#
/usr/bin/caffeinate -i -s -d -t 60 &
/bin/sleep 5

# Remove LogOutUser script and com.smartcard.LogOutUser LaunchAgent
/bin/rm /private/tmp/LogOutUser.sh
/bin/rm /Library/LaunchAgents/com.smartcard.LogOutUser.plist
#
# Log user out
/bin/launchctl bootout user/$(/usr/bin/id -u "$currentUser")

# Unload LaunchAgent com.jamf.LogOutUser
/bin/launchctl bootout system/com.smartcard.LogOutUser
#
SCRIPT
# Set permissions for script
/usr/sbin/chown root:wheel /private/tmp/LogOutUser.sh
/bin/chmod 755 /private/tmp/LogOutUser.sh
# log "End ${FUNCNAME[0]}"
}
###
#

#
### Create LaunchAgent com.smartcard.LogOutUser.plist ###
function Create_LogOut_LaunchAgent () {
log "Begin ${FUNCNAME[0]}"
/bin/cat > "/Library/LaunchAgents/com.smartcard.LogOutUser.plist" << 'LaunchAgent'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.smartcard.LogOutUser</string>
	<key>ProgramArguments</key>
	<array>
		<string>/private/tmp/LogOutUser.sh</string>
	</array>
	<key>LaunchOnlyOnce</key>
	<true/>
	<key>RunAtLoad</key>
	<true/>
</dict>
</plist>
LaunchAgent
# Set permissions for LaunchAgent
/usr/sbin/chown root:wheel /Library/LaunchAgents/com.smartcard.LogOutUser.plist
/bin/chmod 644 /Library/LaunchAgents/com.smartcard.LogOutUser.plist
/usr/bin/plutil -convert xml1 /Library/LaunchAgents/com.smartcard.LogOutUser.plist
# Run LaunchAgent
/bin/launchctl bootstrap system/ /Library/LaunchAgents/com.smartcard.LogOutUser.plist
# log "End ${FUNCNAME[0]}"
}
###
#

####################################################################################################
#
# SCRIPT CONTENTS
#
####################################################################################################

if [[ "$sw_vers_Major_Integer" -lt 1014 ]]; then
	/bin/echo "This script requires 10.14 or greater. Exiting now."
	exit 1
fi

rootcheck

Wait_For_Dock

Check_For_UsersToExclude

Check_current_user_for_mapped_smart_card

EnableCTK

IntroMessage

Check_for_PIV_Auth_Cert

Test_Smart_Card_PIN

checkForPaired

getUPN

createAltSecId

exit 0
